파일 포맷 설계는 크게 **아래의 과정**을 거친다

1. **주소 지정 방식 결정**
2. **전체 파일 구조 설계**
3. **스키마 설계**
4. **세부 데이터 레이아웃**

이러한 설계 흐름을 따라가며, 각 단계에서 고려해야 할 핵심 개념들과 설계 원칙들을 자세히 살펴보자


## 주소 지정 방식 결정

### 페이지 구성 방식의 두 가지 접근법

파일 포맷 설계의 첫 번째 단계는 **주소 지정 방식을 결정**하는 것이다
</br>이는 파일을 어떤 단위로 나누어 관리할 것인지를 결정하는 중요한 선택으로, 크게 두 가지 방식이 있다

#### 1. 단일 블록 페이지 방식
:  하나의 페이지가 정확히 하나의 디스크 블록에 대응
-  페이지 크기 = 디스크 블록 크기 
-  주소 계산이 매우 간단 (페이지 번호 × 페이지 크기 = 실제 위치)

#### 2. 다중 블록 페이지 방식

: 하나의 페이지가 여러 개의 연속된 디스크 블록으로 구성
-  페이지 크기 > 디스크 블록 크기 (예: 16KB 페이지 = 4개의 4KB 블록)
-  더 큰 단위로 데이터를 읽어서 순차 읽기 성능 향상

### 저장소 업데이트 방식과의 연관성

주소 지정 방식의 선택은 새로운 레코드를 추가하는 저장소의 **업데이트 전략**과 밀접한 관련이 있다

#### In-Place Update (제자리 업데이트) 방식
: 기존 데이터를 직접 수정하는 방식
<center><img src="in-place-insert.png" width="600" height="200"></center>

- **모든 페이지가 동일한 크기**여야 하는데, 동일한 크기의 페이지를 사용해야 주소 계산이 간단해지고 읽기와 쓰기 접근을 크게 단순화할 수 있어서 특정 위치의 데이터를 바로 찾아서 수정할 수 있기 때문
- 주로 B-Tree, 관계형 데이터베이스 사용됨


#### Append-Only (추가 전용) 방식

: 항상 파일 끝에 새 데이터 추가
<center><img src="append-only.png" width="600" height="500"></center>

- 페이지별로 크기가 달라도 됨
- 메모리에서 페이지 단위로 데이터를 모았다가, 페이지가 가득 차면 한 번에 디스크로 flush함
- LSM Tree, 로그 파일, NoSQL 시스템에 주로 사용


## 전체 파일 구조 설계

### 기본 파일 구조 vs 데이터베이스 파일 구조

#### 기본 파일 구조

```
┌─────────────┐
│   Header    │ ← 고정 크기, 메타데이터
├─────────────┤
│   Page 1    │ ← 동일한 크기
├─────────────┤
│   Page 2    │ ← 동일한 크기  
├─────────────┤
│     ...     │
├─────────────┤
│   Page N    │ ← 동일한 크기
├─────────────┤
│   Trailer   │ ← 고정 크기, 체크섬 등
└─────────────┘
```

#### 데이터베이스 파일 구조

```
┌─────────────────────────────┐
│   Header + Lookup Table     │ ← 룩업 테이블 추가
├─────────────────────────────┤
│   Employee Data Section     │ ← 다양한 크기 가능
├─────────────────────────────┤
│   Department Data Section   │ ← 다양한 크기 가능
├─────────────────────────────┤
│   Index Data Section        │ ← 다양한 크기 가능
├─────────────────────────────┤
│   Log Data Section          │ ← 다양한 크기 가능
├─────────────────────────────┤
│          Trailer            │
└─────────────────────────────┘
```

### 룩업 테이블(Lookup Table) ?

데이터베이스 파일 구조와 기본 파일 구조에서 가장 차이가 보이는 점은 **헤더에 포함된 룩업 테이블**이다.
룩업 테이블은 책의 목차와 같이 원하는 내용이 몇 페이지에 있는지 목차를 보고 바로 찾아갈 수 있는 역할을 한다 

- 파일 내 각 섹션의 시작 위치와 크기 정보를 기록한 "목차"
- 원하는 데이터 섹션을 빠르게 찾아갈 수 있는 네비게이션 도구
- 파일 헤더, 트레일러, 또는 별도 파일에 저장

#### 룩업 테이블 예시

```
Lookup Table in File Header:
┌─────────────────────────────────────┐
│ Employee_Data    → Offset: 1024     │
│ Department_Data  → Offset: 51024    │  
│ Index_Data       → Offset: 61024    │
│ Log_Data         → Offset: 86024    │
└─────────────────────────────────────┘
```

#### 룩업 테이블의 장점

- **O(1) 접근**: 원하는 섹션으로 바로 점프 가능
- **효율성**: 전체 파일을 스캔할 필요 없음
- **확장성**: 새로운 섹션 추가가 용이
- **유지보수성**: 각 섹션을 독립적으로 관리 가능

---

## 스키마 설계

### 고정 스키마(Fixed Schema)

파일 구조를 설계했다면, **실제 데이터를 어떻게 저장할 것인지**에 대한 스키마를 설계도 고려해봐야한다
#### 고정 스키마란?

: 테이블의 필드 개수, 순서, 타입을 미리 정의해 놓은 구조
- 모든 레코드가 동일한 구조를 가짐
- 필드명을 반복 저장하지 않아 디스크 공간을 절약하고, 위치 기반 접근으로 빠른 데이터 액세스가 가능함

    ```
    // 스키마 없이 저장할 경우
    "name:John,birth:1990-01-01,tax:123456,gender:M"
    "name:Sarah,birth:1985-05-15,tax:789012,gender:F"
    → 필드명(name, birth, tax, gender)을 매번 반복 저장

    // 고정 스키마로 저장할 경우
    스키마: [employee_id, tax_number, birth_date, gender, first_name, last_name]
    레코드 1: [1, 123456, 1990-01-01, M, "John", "Doe"]  
    레코드 2: [2, 789012, 1985-05-15, F, "Sarah", "Smith"]
    → 필드명 없이 위치(position)로만 저장
    ```

### 가변 길이 필드 처리 전략

실제 데이터베이스에서는 문자열과 같은 **가변 길이 필드**를 효율적으로 처리해야하는데
책에서는 

#### 책의 예시: 회사 직원 정보 저장

```
고정 길이 필드들 (Fixed-size fields):
┌─────────────────────────────────────────────────────┐
│ employee_id (4 bytes) │ tax_number (4 bytes)        │
│ birth_date (3 bytes)  │ gender (1 byte)             │  
│ first_name_length (2) │ last_name_length (2)        │
└─────────────────────────────────────────────────────┘
총 16 bytes

가변 길이 필드들 (Variable-size fields):
┌─────────────────────────────────────────┐
│ first_name (first_name_length bytes)    │
│ last_name (last_name_length bytes)      │
└─────────────────────────────────────────┘
```

### 가변 길이 필드 접근 방식 비교

#### 방법 1: 길이 계산 방식

```
first_name 접근: 고정영역(16) + 0 = 16번째 위치
last_name 접근: 고정영역(16) + first_name_length(4) = 20번째 위치
```

**문제점**: last_name에 접근하려면 앞의 모든 가변 필드 길이를 계산해야 함

#### 방법 2: 오프셋 저장 방식 

```
고정 영역에 미리 저장:
┌─────────────────────────────────────────────────────┐
│ employee_id (4)    │ tax_number (4)                 │
│ birth_date (3)     │ gender (1)                     │
│ first_name_offset  │ first_name_length              │
│ last_name_offset   │ last_name_length               │
└─────────────────────────────────────────────────────┘

실제 사용:
- first_name: offset=16, length=4 → 위치 16에서 4바이트 읽기
- last_name: offset=20, length=3 → 위치 20에서 3바이트 읽기
```

#### 오프셋 저장 방식의 장점

- **직접 접근**: 계산 없이 바로 해당 위치로 점프
- **성능**: O(1) 접근 시간 보장
- **확장성**: 필드 개수가 늘어나도 성능 저하 없음
- **유지보수성**: 각 필드를 독립적으로 접근 가능

### 계층 구조

실제 데이터베이스 시스템에서는 **복잡한 계층 구조**가 필요하다

#### 계층 구조의 형태

```
Primitives (기본 타입)
    ↓
Fields (필드) - int, string, date로 구성된 필드들
    ↓  
Cells (셀) - 여러 필드로 구성된 완전한 레코드
    ↓
Pages (페이지) - 여러 셀들을 모은 페이지
    ↓
Sections (섹션) - 여러 페이지들을 모은 섹션  
    ↓
Regions (리전) - 여러 섹션들을 모은 리전
```

## 세부 데이터 레이아웃

**슬롯 페이지(Slotted Page)**와 **셀(Cell) 구조**



---
